<!DOCTYPE html>
<html lang="en-GB">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Large language models wonâ€™t replace the programmers tomorrow | Greybeard Consulting</title>
    <meta name="description" content="A home to Philosophy, Science, Music and Software">
    <link rel="stylesheet" href="/assets/style.7dd4d57f.css">
    <link rel="modulepreload" href="/assets/app.79f5a03d.js">
    <link rel="modulepreload" href="/assets/llms-replace-humans.md.ccf4f643.lean.js">
    
    <meta name="twitter:title" content="Large language models wonâ€™t replace the programmers tomorrow | Greybeard Consulting">
  <meta property="og:title" content="Large language models wonâ€™t replace the programmers tomorrow | Greybeard Consulting">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="Greybeard Consulting, back to home" data-v-675d8756 data-v-cc01ef16><!----> Greybeard Consulting</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><!----></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><!----><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="#the-fickle-genie">The fickle genie</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#full-self-driving-still-needs-a-driver">Full self-driving still needs a driver</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#next-token-prediction-is-not-thinking">Next token prediction is not thinking</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#minor-complaints">Minor complaints</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#some-background-on-neuroscience">Some background on Neuroscience</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#ground-for-improvement">Ground for improvement</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#the-way-forward">The way forward</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#conclusion">Conclusion</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h1 id="large-language-models-wonâ€™t-replace-the-programmers-tomorrow" tabindex="-1">Large language models wonâ€™t replace the programmers tomorrow <a class="header-anchor" href="#large-language-models-wonâ€™t-replace-the-programmers-tomorrow" aria-hidden="true">#</a></h1><p><a href="https://commons.wikimedia.org/wiki/File:IBM_150_Extra_Engineers_1951.jpg" target="_blank" rel="noopener noreferrer"><img src="https://upload.wikimedia.org/wikipedia/commons/b/b8/IBM_150_Extra_Engineers_1951.jpg" alt=""></a></p><p>Hi!</p><h2 id="the-fickle-genie" tabindex="-1">The fickle genie <a class="header-anchor" href="#the-fickle-genie" aria-hidden="true">#</a></h2><p>Odds are, you&#39;re fuming with anger having clicked on an obvious clickbait, trying to capitalise on... shall we say... the mass disaster of the day. After all, there <em>were</em> many who underestimated the development of ML models, and there are some skeptical to this day. Some of the artists who were laughing years ago, are protesting today, boycotting the use of statistical models and generative &quot;art&quot;. Still, there is a <strong>but</strong>.</p><p>LLMs generate numbers. Numbers can be text tokens, can be pixels, sound, 3d models, or they could be machine instructions including code and outputs of some compilers and systems like verilog. The efficacy of LLMs is predicated on the tooling. And, you see, programming is not just about writing code and knowing the proper names of certain things. Otherwise, compilers would have replaced programmers long ago. Oh no, programming is a language skill, coupled with some real-world experience, that would allow a programmer to spot a mistake in the technical specifications of the code that they are asked to write; more often than not the program does exactly what you asked it to do, but just like a fickle genie, it doesn&#39;t correct for &quot;common-sense&quot;.</p><h2 id="full-self-driving-still-needs-a-driver" tabindex="-1">Full self-driving still needs a driver <a class="header-anchor" href="#full-self-driving-still-needs-a-driver" aria-hidden="true">#</a></h2><p>The guiding principle of transformers and transformer-like models is next token prediction. Imagine, you remember a lot and speak long sentences without thinking much. Thatâ€™ll be rather similar to the results of the process that most LLMs utilise to generate the &quot;magical&quot; results. These methods can be weaponised to search for text, or they could be used for word substitution.</p><p>But, I argue, that&#39;s still far from &quot;solving a problem&quot;; it&#39;s not about building an action plan, executing the actions and tracking their flow, just stochastic parroting. It can mimic structures that resemble, or rather allow us to project these qualities, when in fact the underlying model has no concept/understanding of what a plan would even mean. Some may disagree and point to the concept of multi-headed attention<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> as a way of imitating a thinking process. I disagree, and as I argued earlier, this is a function of observer projection and not genuine procedural conceptualisation.</p><p>You indeed can ask an LLM to criticize your code or its documentation. A (relatively) fresh LLM that was trained on language code and documentation might even be helpful, but not to anyone beyond the first stages of learning, or deeply invested in seeing competence. You can query it for debugger interactions and it might help. There&#39;s also a chance that it is hallucinating, and it might lead you down a wild goose chace, though if it does, you can simply repeat the request. The system still requires a human to oversee the operation of the LLM. It&#39;s no auto-pilot if you still need a human to take over the driving, if the &quot;full-self-driving&quot; does something so stupid that it could have been caught algorithmically.</p><p>So LLMs are not as thorough, and cannot, at present, fully automate the existence of a human behind a screen doing the legwork. It didn&#39;t stop a marketing misnomer LLMs -- &quot;AIs&quot; to have become popular. Let us suppose that all thinking is algorithmic (which is not a falsifiable theory), and also suppose that a thinking machine might think without having a model of the world explicitly, but implicit in its weights. Can LLMs answer questions on programming in languages that haven&#39;t been invented at the time of their training? Will they be as accurate? Can they work off of limited training data, as most humans do? It still doesn&#39;t cut it.</p><p>Rather than regurgitating our earlier discussion in the old <a href="https://odysee.com/@CyberLounge:a/will-ai-ever-replace-human-programmers-part-3:c" target="_blank" rel="noopener noreferrer">CyberLounge</a>, we will focus on newer developments. The conclusion hasn&#39;t changed, but the inputs might fool you into thinking that it did.</p><p>So without further ado.</p><h2 id="next-token-prediction-is-not-thinking" tabindex="-1">Next token prediction is not thinking <a class="header-anchor" href="#next-token-prediction-is-not-thinking" aria-hidden="true">#</a></h2><p>To find out why, letâ€™s get meta: think about how we think. &quot;Iâ€™d put this word here, because it looks relatively appropriate&quot;? Maybe it&#39;s something I do occasionally when writing documentation in a foreign language, but not routinely. Our way of solving problems is spread over several distinct layers of abstraction, starting with concepts and ending in language. We descend the layers of abstraction from the conceptual stage, where we have plans and actions, concepts and inferences, we have what I would argue, thought in its purest and most abstract form. At this stage we can think in terms of vague pictures, or formulae, or even nothing explicit, nothing we can even verbalise. Case in point, Feynman was thinking with pictures, and his diagrams were helpful, but that abstraction was not a pre-existing statistical result that was extrapolated, but rather an emergent consequence of familiarity with Wick&#39;s theorem. LLMs have no room for such an abstract process, or at least, it&#39;s hard to tell. True, they <em>could</em> have this, but that is an extraordinary claim, backed by (at best) lack of any evidence to the contrary.</p><p>Too vague? Let&#39;s consider an example and assume you&#39;re making a small UI component, using HTML+CSS or some GUI library. The ML model would be able to generate the form code, but only sometimes and often semi-accurately. A week ago we, Greybeard, asked GPT-4 to write the code for a CSS-only image gallery. The code simply did not work. It was like a straight F student copying the work of a straight A student, without even remotely understanding what they were doing. It&#39;d be an automatic fail for anyone reasonable, but let&#39;s indulge the &quot;true believers&quot;.</p><p>Let&#39;s assume there&#39;s a tiniest bit of design involved: there are limited field widths and the designer decided to integrate the icons into the form fields. How would an LLM be sure that the result matches the criteria without seeing it? One could think of things like <a href="https://cliport.github.io/" target="_blank" rel="noopener noreferrer">CLIPort</a> that was made for robotic manipulators or <a href="https://llava-vl.github.io/" target="_blank" rel="noopener noreferrer">LLaVA</a> made to work with vision-related tasks, but modifying GPT to interact with it and to reason about the design is not the easiest task. As a human, and as someone who has worked with HTML for a very long time, given structure of the document, I can project what it would look like; I can do almost as well in my mind&#39;s eye, as the browser can in its canvas. The LLM, could in principle interface with the browser to render the results exactly, yet doesn&#39;t even &quot;think&quot; to do that. Predictably, it will often horrendously misinterpret the constraints, and sometimes ignore them completely.</p><p>Let&#39;s go further. A human can modify the page further, incrementally change the design. Can an LLM do the same? It could generate the code wholesale, but not make surgical adjustments: this would require the model finding precisely where to select the text and to then have an improved word mask model to alter the text at least slighlty more effecively than now. Using an LLM with a prompt fed to it to alter the same section will lead to multitudes of hallucination iterations to be handled, and it&#39;s not fun to handle whatsoever. The <a href="https://www.youtube.com/watch?v=RDd71IUIgpg&amp;t=311s" target="_blank" rel="noopener noreferrer">primagean</a> demonstrated the problems in using GitHub Copilot. The LLM simply ignores some of the constraints in the video, it generated a frames-per-second where the time was measured in miliseconds. I know of some models that guess a masked word[^Bert_word-masking][^fill-mask], but doing the inverse with a set goal <strong>consistently</strong>? It&#39;s not impossible, but it may very well be tedious to tune. And maybe said models could be reused. Creating a corpus for these models is a massive work, and one should cover all edge-cases with many models. According to TIME, &quot;<a href="https://time.com/6247678/openai-chatgpt-kenya-workers/" target="_blank" rel="noopener noreferrer">OpenAI Used Kenyan Workers on Less Than $2 Per Hour to Make ChatGPT Less Toxic</a>&quot;. Are there enough people to work on all of these tasks?</p><h2 id="minor-complaints" tabindex="-1">Minor complaints <a class="header-anchor" href="#minor-complaints" aria-hidden="true">#</a></h2><p>It gets sillier! Often enough, LLMs simply stop writing the text and you need to make them continue from that point on manually! I haven&#39;t yet seen a cover-all method that allows LLMs to automatically start and stop, GPT-4 included. Maybe GPT-5 will do that? ChatGPT in particular sometimes breaks and writes the code after the highlight, so even if one had direct API access, weaponising this to replace an engineer would be a monumental task, defeating the original intention.</p><h2 id="some-background-on-neuroscience" tabindex="-1">Some background on Neuroscience <a class="header-anchor" href="#some-background-on-neuroscience" aria-hidden="true">#</a></h2><p>Our brains <strong>remember related information</strong>, perform action selection<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> based on the outside context provided by our senses, while <strong>filtering inappropriate actions out</strong>. Thatâ€™s quite different in comparison to the LLMs, which, in turn, <a href="https://writings.stephenwolfram.com/2023/02/what-is-chatgpt-doing-and-why-does-it-work/" target="_blank" rel="noopener noreferrer">generate the most probable next token</a>. Besides, the modern LLMs are limited by the data provided in training dataset: they donâ€™t retrieve new information<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>. We&#39;re still stuck with the machine learning methods that can&#39;t learn real-time, requiring the immense arrays of hardware to do the training. The popular ChatGPT failed to cobble up a word of a given length out of the letters I&#39;ve picked, which Python (that is considered to be slow by many) does in less than a second on my cheap laptop. Several times in a row, because I wanted to be fair towards it and repeated my test. Itâ€™s not a description for super (or human-level) intelligence, really.</p><p>Sure, you could make the argument that some vague future models might approach the problem better. I would revisit this discussion at that time, because right now, we are projecting superhuman intelligence onto a stochastic parrot. Plus, given the no-free-lunch theorem, if there ever will be an artificial general intelligence, it will <strong>have</strong> to be only partially statistical in nature. Plus, there&#39;s a good chance that by the time we have something like AGI, we will have deepened our knowledge and there&#39;s still something somewhere that the artificial intelligence does worse than a human (for one, our brains have exceptional power efficiency).</p><h2 id="ground-for-improvement" tabindex="-1">Ground for improvement <a class="header-anchor" href="#ground-for-improvement" aria-hidden="true">#</a></h2><p>Now, let&#39;s talk about a thing to improve. LLMs need to be able to assess what they write. If an LLM writes five or seven-letter words when itâ€™s being requested to write six-letter words, it lacks an ability for self-assesment. If it canâ€™t plan to read codeâ€™s files and pick the one needing change, it lacks planning. Planning does not require interaction with third-party systems, but thatâ€™ll help. And yes, since your LLM isnâ€™t typically connected to the OS in some way, it wonâ€™t interact with the project files or create a project for you. So no, LLMs wonâ€™t replace the human programmer, not yet. They would needs more parts attached. It&#39;s not all doom and gloom, many are thinking about LLMs lacking in capabilities nowadays. Thereâ€™s the project <a href="https://github.com/ezelikman/parsel" target="_blank" rel="noopener noreferrer">Parsel project</a> that partially addresses this problem. It is described as:</p><blockquote><p>A framework enabling automatic implementation and validation of complex algorithms with code LLMs, taking hierarchical function descriptions in natural language as input&quot;</p></blockquote><p>While this sounds complex, <em>Parsel</em> solves an important task: generating the code from the natural language description using constraints.</p><p>We also need to feed data to somehow provide the context. The &quot;<a href="https://github.com/keerthanpg/talktopapers/blob/master/TalkToPapers.ipynb" target="_blank" rel="noopener noreferrer">Talk to papers</a>&quot; and &quot;<a href="https://github.com/keerthanpg/TalkToCode" target="_blank" rel="noopener noreferrer">Talk to code</a>&quot; demos show us an important detail of the process: the use of text embeddings (vectors pointing to a message for a language model) to look up the related info. That is a small part, which would be quite important for navigating the source code of the project, although best combined with the other search algorithms.</p><p>Imagine we want our LLM to draw a form to input the bank account details. It will be able to do the basic one. It will be able to mock something using the Bootstrap CSS framework. It will not see anything, unless connected to another neural net that has such a modality. <a href="https://openai.com/blog/clip/" target="_blank" rel="noopener noreferrer">CLIP</a> and other similar neural networks have the ability to connect text and images, often with limited resolution, and may help a bit already. The whole field advanced slightly with the <a href="https://openai.com/blog/multimodal-neurons/" target="_blank" rel="noopener noreferrer">multimodal neurons</a> representing the concepts being located. Otherwise, I&#39;d simply say our civilization just started tinkering with multiple modalities.</p><p>Now, weâ€™re getting to the interesting part. How does our system select actions? How does it even know what actions it can perform? Through some API bindings that allow it to work with a codebase? Itâ€™s not even close to what LLMs currently have. There are many ML solutions for selecting an action, starting with the reinforcement learning agents and finishing with the exotic ideas like animats, though. Thereâ€™s even a <a href="https://say-can.github.io/" target="_blank" rel="noopener noreferrer">SayCan</a> assistant who has this exact ability. The problem here is that RL agents would perfectly know the possible actions, while itâ€™s more vague with the code.</p><p>And thereâ€™s much more to machine learning than any large language model had achieved! LLMs are only a small part of what&#39;s being done, and not each part is easy to understand and appreciate. We&#39;re only starting and it&#39;s naive to assume we&#39;re going to get the complete imitation of our thinking or an improvement over it this decade.</p><p><a href="https://openai.com/" target="_blank" rel="noopener noreferrer">OpenAI</a>, the same company that created ChatGPT, made a great demo<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> with robots and reinforcement learning, but people outside the company donâ€™t interact with those proprietary networks much, so the fate of this technology for now is to be seen as Â«fun videos on YouTube with robots playing hide and seekÂ». That for a story, where robots learned how to use tools, something many biological species canâ€™t do!</p><p>Everyone is talking about ChatGPT, while the same company has GPT-instruct, that can learn on a set of ideas provided and has much less limitations as a less popular product. While one thing is being polished for the public use, a thing that&#39;ll give better results is discussed less! It makes me smile when a newbie does that, but when businesses change their strategies over ChatGPT while ignoring everything that was there before it, it is simply hilarious.</p><p>It is both amusing and bemusing to think that some people even consider replacing any part of their software engineering teams with &quot;A.&quot;&quot;I.&quot;. You see, if we approach this in the straightforward way, the very people who work with ML models should be replaced through the sheer amount of data available on ML code. But does the code itself represent the whole process here? Given how much is hidden in the dataset and the model configuration, I highly doubt it. The code is not guaranteed to be straightforward and have a good architecture, it is not even guaranteed to make much sense at the first glance, yet there is a place and time for &quot;scientific style of programming&quot;, which we often see in ML. But let&#39;s not stop here and pick something much easier. Historically, code that writes code was called different names, for example, &quot;symbolic regression&quot; and &quot;genetic programming&quot;. And heck, given how much goes into picking data and tuning the genetic programming libraties, I dream about it being automated. The code is short, usually representing some visualization and a config parser. And yet, each time there&#39;s still some small trick to the data, something to optimize. LLMs won&#39;t infer formulas and won&#39;t configure the Cartesian Genetic Programming systems to make some DSP filter for sound or images soon. For now, they&#39;ll help generate the glue code.</p><h2 id="the-way-forward" tabindex="-1">The way forward <a class="header-anchor" href="#the-way-forward" aria-hidden="true">#</a></h2><p>Finally, the scientists are tinkering with the ideas, which may put those technologies in our homes, instead of the large research labs with massive funding.</p><p>Letâ€™s discuss something called a <a href="https://en.wikipedia.org/wiki/Memristor" target="_blank" rel="noopener noreferrer">memristor</a> or a memory resistor, starting from the basics. Normal resistors reduce the current flow in electronic circuits and do a lot more useful stuff by converting electric power to heat. So far it is not new, but at some point, the transistors appeared: something that acts like a resistor, but can be controlled by applying the electric power. Now, with the ability to make something complex, like logic gates, people tinkered with the technology more and more, made it smaller and smaller, integrated gates to complex circuits, and now weâ€™ve got the powerful computers in our pockets. What crazy networks with miriads of parts can we expect from yet another Â«more complex resistor siblingÂ», then? Memristors have a great potential for machine learning, because each of them has a way to store information, while resistance may be used to process it in analog way. This is quite similar to what neurons in our brains do. The progress of memristor development was partially parallel to the transistors, since the term was coined in 1971 by <a href="https://en.wikipedia.org/wiki/Leon_O._Chua" target="_blank" rel="noopener noreferrer">Leon Chua</a>. I wanted to add one reference to a single-molecule memristor that can be inkjet-printed from an article, but now there seems to be more than one type, plus something that can be tuned by light and another, with a magnetic spin. More importantly, there&#39;s an article that tells about the on-line learning ability of the memristor networks now<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>. The memristors may very well provide us with an ability to train such networks at the leisure of our homes at some point in future. But for now, we&#39;ve got the disconnected ML models doing some parts of the whole we need.</p><p>Besides the training, there are other companies having impressive results, for example, <a href="https://optalysys.com/" target="_blank" rel="noopener noreferrer">Optalysis</a>. They&#39;re using the Fourier transform caused by an optical system to immediately perform ML inference tasks. In their article, &quot;<a href="https://web.archive.org/web/20221210061657/https://optalysys.com/optical-computing-and-transformer-networks/" target="_blank" rel="noopener noreferrer">Optalysis and Fourier-based transformers</a>&quot;, they claim that they were able to impressively accelerate the transformer inference. While it&#39;s nowhere near something necessary for training, these devices may soon be an amazing extensions for the workstations, and someday, home computers, also allowing us to run these networks locally. MythicAI had <a href="https://youtu.be/GVsUOuSjvcg?t=961" target="_blank" rel="noopener noreferrer">demonstrated</a> a way to run ML tasks on a RAM chip, using its other properties. This can be an alternative to what Optalysis is doing with the Fourier optics.</p><h2 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-hidden="true">#</a></h2><p>We have demonstrated that at present, us meatbags can look forward to a new type of work, namely fixing what the LLM has generated, instead of writing it out ourselves. Human programmers will be a tad more productive, naturally this will not result in higher compensation. We live in a perverse world, and a 10x improvement in productivity won&#39;t make most software engineers 10x the pay, though it should, and under a different economic system, one the US had before 1972 it would.</p><p>The advent of LLMs will not reduce the amount of workplaces for people of the software-engineering bend. What it will result in, is you no longer having to write a dumb function to do something simple, but oversee that the function that was generated by the LLM isn&#39;t too dumb.</p><p>Fearmongering, and perverse incentives will make most script kiddies nervous, because what they need several hours to do, Copilot or ChatGPT will do in a fraction of a second. Guess what, there used to be a profession called &quot;computer&quot;, where humans did computations by hand, something like figuring out what the $\log_{10} 3.1416$ is for some logarithmic table or slide rule, the kind of work changed, but a mathematical profession needed for automation never went away. Software engineering will likely rebrand to something else, but the people with particular skills and proclivities will find a position managing the automatic tools.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener noreferrer">Attention Is All You Need</a>, Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, Illia Polosukhin, 2017 <a href="#fnref1" class="footnote-backref">â†©ï¸Ž</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://compcogneuro.org/" target="_blank" rel="noopener noreferrer">Computational Cognitive Neuroscience, 4th Edition</a> by R. C. O&#39;Reilly, Y. Munakata, M. J. Frank, T. E. Hazy, &amp; Contributors, &quot;Chapter 7: Motor Control and Reinforcement Learning&quot;, &quot;Basal Ganglia, Action Selection and Reinforcement Learning&quot; <a href="#fnref2" class="footnote-backref">â†©ï¸Ž</a></p></li><li id="fn3" class="footnote-item"><p>I hope that ChatGPT will use the results of the user&#39;s estimation as the training data, but we&#39;ll see. <a href="#fnref3" class="footnote-backref">â†©ï¸Ž</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.youtube.com/watch?v=Lu56xVlZ40M" target="_blank" rel="noopener noreferrer">OpenAI Plays Hide and Seekâ€¦and Breaks The Game! ðŸ¤–</a> <a href="#fnref4" class="footnote-backref">â†©ï¸Ž</a></p></li><li id="fn5" class="footnote-item"><p>&quot;<a href="https://asic2.group/wp-content/uploads/2017/05/TNNLS.pdf" target="_blank" rel="noopener noreferrer">Memristor-Based Multilayer Neural Networks With Online Gradient Descent Training</a>&quot; by Daniel Soudry, Dotan Di Castro, Asaf Gal, Avinoam Kolodny, and Shahar Kvatinsky <a href="#fnref5" class="footnote-backref">â†©ï¸Ž</a></p></li></ol></section></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-07c132fc><div class="edit" data-v-07c132fc><div class="edit-link" data-v-07c132fc data-v-1ed99556><!----></div></div><div class="updated" data-v-07c132fc><!----></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"f35d195b\",\"linux-phone-security.md\":\"0545af9f\",\"llms-replace-humans.md\":\"ccf4f643\"}")</script>
    <script type="module" async src="/assets/app.79f5a03d.js"></script>
    
  </body>
</html>